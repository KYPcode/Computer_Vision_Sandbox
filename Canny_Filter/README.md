# Canny Filter

The analysis by Canny filter is done in two steps:

1) **Image smoothing**: To simplify the image and reduce noise, the image will be smoothed by a Gaussian blurring for example.
2) **Edge detection**: Calculation of the norm of the gradient and the direction of the gradient for each pixel of the smoothed image.

## Image Smoothing
____

In our case, the smoothing of the image will be made from a Gaussian blur.

The Gaussian function is a continuous function that takes as input a real number and returns a real number :

$$ f(x) = \frac{1}{\sigma \sqrt{2\pi}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}$$

This function is used to generate a Gaussian convolution kernel modifying the neighboring pixels according to the content of the matrix. The impacted neighboring pixels will be more or less numerous depending on the size of the matrix and more or less modified depending on the standard deviation (sigma).

In our case, the kernel will be generated by the function ```generate_gaussian_kernel``` which will give us the kernel where the convolution will be applied on the image with the function ```apply_gaussian_filter``` :

```python
def generate_gaussian_kernel(size:tuple[int], sigma:float) -> np.ndarray:
    if size[0] % 2 == 0 or size[1] % 2 == 0:
        raise ValueError("The size of the matrix must be odd.")
        
    matrix = np.empty(size)
    center = (size[0] // 2, size[1] // 2)
    x, y = np.indices(size)
    g = np.exp(-((x - center[0])**2 + (y - center[1])**2) / (2 * sigma**2))
    return g / g.sum()


def apply_gaussian_filter(image, size:tuple[int], sigma:float):
    kernel = generate_gaussian_kernel(size, sigma)
    filtered_image = convolve2d(image, kernel, mode='same')
    return filtered_image
```

## Edges Detection
____

This step, which comes after the Gaussian smoothing, consists first of all of calculating the vertical and horizontal gradients (*corresponding to the direction and intensity of the variation in luminosity in the image*) using a derivation operator, which in this case will be the **Sobel** filter.

The Sobel filter (but not only) calculates the gradients using convolution masks (small matrices applied to the image to calculate the weighted sum of the intensities of the neighboring pixels around the current pixel). In the case of the Sobel filter, the horizontal and vertical gradient values are : 

$$
G_x = \begin{bmatrix}
-1 & 0 & 1 \\
-2 & 0 & 2 \\
-1 & 0 & 1
\end{bmatrix}
\qquad
G_y = \begin{bmatrix}
1 & 2 & 1 \\
0 & 0 & 0 \\
-1 & -2 & -1
\end{bmatrix}
$$

These gradients will then be used to calculate the magnitude of the gradient corresponding to :

$$\sqrt{{G_x}^2+{G_y}^2}$$

In addition to the magnitude, we can also calculate the orientation of the gradient:

$$
\theta = \text{arctan}(\frac{G_y}{G_x})
$$

Thanks to these two measurements, we will have a way to get an idea of the orientation that the contour will take and especially of its intensity. The **suppression of non-maximums** (performed by the ```non_maximum_suppression``` function) which consists in keeping the pixels whose value is maximum compared to the two pixels on either side along the direction of the gradient because these pixels will correspond to sharp contours.

```python
def non_maximum_suppression(magnitude, direction):
	for y in range(1, len(magnitude)-1):
		for x in range(1,len(magnitude[0])-1):
			rounded_direction = 45 * np.round(direction[y][x] / 45.0)
			
			if rounded_direction == 0:
				if magnitude[y][x-1] >= magnitude[y][x] or magnitude[y][x+1] >= magnitude[y][x]:
					magnitude[y][x] = 0
			
			elif rounded_direction == 45:
				if magnitude[y+1][x+1] >= magnitude[y][x] or magnitude[y+1][x-1] >= magnitude[y][x]:
					magnitude[y][x] = 0
			
			elif rounded_direction == 90:
				if magnitude[y+1][x] >= magnitude[y][x] or magnitude[y-1][x] >= magnitude[y][x]:
					magnitude[y][x] = 0
			
			elif rounded_direction == 180:
				if magnitude[y+1][x+1] >= magnitude[y][x] or magnitude[y-1][x-1] >= magnitude[y][x]:
					magnitude[y][x] = 0
	return magnitude
```

After the non-maximum suppression step, we obtain an image where edges are represented by strong and weak edge pixels, depending on whether their gradient magnitude is greater than a high threshold or between a low and high threshold, respectively. To obtain a binary image of edges, we apply the **hysteresis** thresholding technique (performed by ```hysteresis_thresholding``` function), which involves starting from the strong edge pixels and iteratively adding their neighboring weak edge pixels that are connected to them. This process continues until no more weak edge pixels can be added. The resulting binary image contains only the edges that were connected to strong edge pixels, and the choice of the low and high thresholds determines the sensitivity of the edge detection algorithm.

```python
def hysteresis_thresholding(suppressed, low_threshold, high_threshold):
	high_mask = suppressed >= high_threshold
	low_mask = (suppressed >= low_threshold) & (suppressed < high_threshold)
	
	binary_image = np.zeros_like(suppressed)
	binary_image[high_mask] = 255
	
	y, x = np.where(low_mask) 
	
	for i in range(len(y)):
		if (y[i] > 0 and binary_image[y[i]-1, x[i]] == 255) \
			or (y[i] < suppressed.shape[0]-1 and binary_image[y[i]+1, x[i]] == 255) \
			or (x[i] > 0 and binary_image[y[i], x[i]-1] == 255) \
			or (x[i] < suppressed.shape[1]-1 and binary_image[y[i], x[i]+1] == 255) \
			or (y[i] > 0 and x[i] > 0 and binary_image[y[i]-1, x[i]-1] == 255) \
			or (y[i] > 0 and x[i] < suppressed.shape[1]-1 and binary_image[y[i]-1, x[i]+1] == 255) \
			or (y[i] < suppressed.shape[0]-1 and x[i] > 0 and binary_image[y[i]+1, x[i]-1] == 255) \
			or (y[i] < suppressed.shape[0]-1 and x[i] < suppressed.shape[1]-1 and binary_image[y[i]+1, x[i]+1] == 255):
					binary_image[y[i], x[i]] = 255
	
	return binary_image
```

Finally, all of these steps are contained in the ```canny_filter``` function:

```python
def canny_filter(image,low_threshold,high_threshold):
	# Sobel Filter
	grad_x = convolve2d(image,np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]), mode='same')
	grad_y = convolve2d(image,np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]]), mode='same')
	
	magnitude = np.sqrt(grad_x**2 + grad_y**2)
	direction = np.arctan2(grad_y, grad_x)
	
	magnitude = non_maximum_suppression(magnitude, direction)
	edges = hysteresis_thresholding(magnitude, low_threshold, high_threshold)
	
	return edges
```
